===========================
crcmod for Calculating CRCs
===========================

The software in this package is a Python module for generating objects that
compute the Cyclic Redundancy Check (CRC).  There is no attempt in this package
to explain how the CRC works.  There are a number of resources on the web that
give a good explanation of the algorithms.  Just do a Google search for "crc
calculation" and browse till you find what you need.  Another resource can be
found in chapter 20 of the book "Numerical Recipes in C" by Press et. al.

This package allows the use of any 8, 16, 24, 32, or 64 bit CRC.  You can
generate a Python function for the selected polynomial or an instance of the
Crc class which provides the same interface as the ``md5`` and ``sha`` modules
from the Python standard library.  A ``Crc`` class instance can also generate
C/C++ source code that can be used in another application.

----------
Guidelines
----------

Documentation is available from the doc strings.  It is up to you to decide
what polynomials to use in your application.  If someone has not specified the
polynomials to use, you will need to do some research to find one suitable for
your application.  Examples are available in the unit test script
``test_crcmod.py`` and the timing script ``timing_test.py``.

If you need to generate code for another language, I suggest you subclass the
``Crc`` class and replace the method ``generateCode``.  Use ``generateCode`` as
a model for the new version.

------------
Dependencies
------------

Python Version
^^^^^^^^^^^^^^

The module has separate code to support the 2.x and 3.x Python series.

For the 2.x versions of Python, these versions have been tested:

* 2.4
* 2.5
* 2.6
* 2.7

It may still work on earlier versions of Python 2.x, but these have not been
recently tested.

For the 3.x versions of Python, these versions have been tested:

* 3.1

Building C extension
^^^^^^^^^^^^^^^^^^^^

To build the C extension, the appropriate compiler tools for your platform must
be installed. Refer to the Python documentation for building C extensions for
details.

------------
Installation
------------

The crcmod package is installed using ``distutils``.
Run the following command::

    python setup.py install

If the extension module builds, it will be installed.  Otherwise, the
installation will include the pure Python version.  This will run significantly
slower than the extension module but will allow the package to be used.

For Python 3.x, the install process is the same but you need to use the 3.x
interpreter.

------------
Unit Testing
------------

The script ``test_crcmod.py`` is the unit test for ``crcmod``.  When you first
install the package, you should run this test to make sure everything is
installed properly.  This script performs a number of tests including a
comparison to the direct method which uses a class implementing polynomials
over the integers mod 2.

The unit test script also demonstrates how to use the code generator.  The
result of this is written out to the file ``examples.c``.  The generated code
was checked to make sure it compiles with the GCC compiler.

-------
License
-------

The ``crcmod`` module is released under the MIT license. See the ``LICENSE``
file for details.

------
Timing
------

A few timing measurements were taken using the ``timeit`` module in the Python
standard library.  The Python implementation is compared to the extension
module, the ``md5`` module in the standard library, and the ``crc32`` function
from the ``binascii`` module.  These measurements were taken on my development
system which is a 3GHz Pentium IV with hyper threading running the Debian Sarge
distribution of Linux with the 2.6.6 version of the kernel.  The Python version
is 2.3.3.

The following result was obtained by running the ``timing_test.py`` script
twice. Once with the Python version and once with the extension module.

======================  ============  ============  ==========================
Module                  min (us)      max (us)      Notes
======================  ============  ============  ==========================
``crcmod``              14981.4       15035.8       Pure Python implementation
``crcmod``              64.2          64.4          C extension module
``md5``                 59.0          59.3        
``binascii.crc32``      87.2          87.4        
======================  ============  ============  ==========================

* Timing in microseconds per iteration
* min and max of 10 repetitions

It is interesting that on this system, the md5 module is slightly faster than a
32-bit CRC even though the message digest is 128-bits and is cryptographically
more secure.  This is surprising since the MD5 code looks a lot more complex.
I tried unrolling the inner loop and using the function interface instead of
the class interface.  These changes only got the result down to where the MD5
and CRC took about the same amount of time.

.. note::
    ``binascii.crc32`` is slower than ``crcmod`` because it includes a mask
    operation to get the low order byte of a 32-bit word.  A cast is used in
    the CRC module to accomplish the same thing.

